import { finalizeEvent } from 'nostr-tools';
import type { NostrEvent, PubkeyHex } from '../../types/nostr';
import { storeEvent } from './db/index.js';

interface ComposeOverlayOptions {
  composeButton: HTMLElement | null;
  getSessionPrivateKey: () => Uint8Array | null;
  getRelays: () => string[];
  publishEvent: (event: NostrEvent, relays: string[]) => Promise<void>;
  refreshTimeline: () => Promise<void>;
}

export function setupComposeOverlay(options: ComposeOverlayOptions): void {
  const overlay: HTMLElement | null =
    document.getElementById('compose-overlay');
  const backdrop: HTMLElement | null = document.getElementById(
    'compose-overlay-backdrop',
  );
  const closeBtn: HTMLElement | null = document.getElementById(
    'compose-overlay-close',
  );
  const textarea: HTMLTextAreaElement | null = document.getElementById(
    'compose-textarea',
  ) as HTMLTextAreaElement;
  const submitBtn: HTMLButtonElement | null = document.getElementById(
    'compose-submit',
  ) as HTMLButtonElement;
  const statusEl: HTMLElement | null =
    document.getElementById('compose-status');

  if (
    !overlay ||
    !backdrop ||
    !closeBtn ||
    !textarea ||
    !submitBtn ||
    !statusEl
  ) {
    return;
  }
  let isSubmitting: boolean = false;

  const openOverlay = (): void => {
    overlay.style.display = '';
    textarea.focus();
  };

  const closeOverlay = (): void => {
    overlay.style.display = 'none';
    statusEl.textContent = '';
  };

  const refreshStatus = (): void => {
    const hasExtension: boolean = Boolean((window as any).nostr?.signEvent);
    const hasPrivateKey: boolean = Boolean(options.getSessionPrivateKey());
    if (hasExtension) {
      statusEl.textContent = 'Signing with extension';
    } else if (hasPrivateKey) {
      statusEl.textContent = 'Signing with private key (session)';
    } else {
      statusEl.textContent = 'Sign-in required to post';
    }

    if (isSubmitting) {
      submitBtn.disabled = true;
      submitBtn.classList.add('opacity-60', 'cursor-not-allowed');
    } else {
      submitBtn.disabled = false;
      submitBtn.classList.remove('opacity-60', 'cursor-not-allowed');
    }
  };

  if (options.composeButton) {
    options.composeButton.addEventListener('click', (): void => {
      refreshStatus();
      openOverlay();
    });
  }

  backdrop.addEventListener('click', closeOverlay);
  closeBtn.addEventListener('click', closeOverlay);

  const isTypingContext = (target: EventTarget | null): boolean => {
    if (!(target instanceof HTMLElement)) {
      return false;
    }

    const tagName: string = target.tagName.toLowerCase();
    if (
      tagName === 'input' ||
      tagName === 'textarea' ||
      target.isContentEditable
    ) {
      return true;
    }

    return false;
  };

  const canOpenCompose = (): boolean => {
    if (!options.composeButton) {
      return false;
    }
    return options.composeButton.style.display !== 'none';
  };

  document.addEventListener('keydown', (event: KeyboardEvent): void => {
    const isOverlayOpen: boolean = overlay.style.display !== 'none';

    if (isOverlayOpen && event.key === 'Escape') {
      closeOverlay();
      return;
    }

    if (
      !isOverlayOpen &&
      event.key.toLowerCase() === 'n' &&
      !isTypingContext(event.target)
    ) {
      if (!canOpenCompose()) {
        return;
      }
      event.preventDefault();
      refreshStatus();
      openOverlay();
      return;
    }

    if (
      isOverlayOpen &&
      event.key === 'Enter' &&
      (event.metaKey || event.ctrlKey)
    ) {
      event.preventDefault();
      if (!submitBtn.disabled) {
        submitBtn.click();
      }
    }
  });

  submitBtn.addEventListener('click', async (): Promise<void> => {
    if (!textarea.value.trim()) {
      textarea.focus();
      return;
    }

    const hasExtension: boolean = Boolean((window as any).nostr?.signEvent);
    const privateKey: Uint8Array | null = options.getSessionPrivateKey();
    if (!hasExtension && !privateKey) {
      statusEl.textContent = 'Sign-in required to post';
      alert(
        'Sign-in required to post. Please log in with extension or private key.',
      );
      refreshStatus();
      return;
    }

    isSubmitting = true;
    refreshStatus();
    statusEl.textContent = 'Posting...';

    try {
      const storedPubkey: string | null = localStorage.getItem('nostr_pubkey');
      if (!storedPubkey) {
        throw new Error('Not logged in');
      }

      const unsignedEvent: Omit<NostrEvent, 'id' | 'sig'> = {
        kind: 1,
        pubkey: storedPubkey as PubkeyHex,
        created_at: Math.floor(Date.now() / 1000),
        tags: [],
        content: textarea.value.trim(),
      };

      let signedEvent: NostrEvent;
      if (hasExtension) {
        signedEvent = await (window as any).nostr.signEvent(unsignedEvent);
      } else {
        if (!privateKey) {
          throw new Error('No signing method available');
        }
        signedEvent = finalizeEvent(unsignedEvent, privateKey) as NostrEvent;
      }

      await options.publishEvent(signedEvent, options.getRelays());
      await storeEvent(signedEvent, { isHomeTimeline: false });
      textarea.value = '';
      statusEl.textContent = 'Posted';
      closeOverlay();
      await options.refreshTimeline();
    } catch (error: unknown) {
      console.error('Failed to post:', error);
      statusEl.textContent = 'Failed to post';
      alert('Failed to post. Please try again.');
    } finally {
      isSubmitting = false;
      refreshStatus();
    }
  });
}
